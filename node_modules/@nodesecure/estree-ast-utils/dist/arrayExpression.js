// Import Internal Dependencies
import { noop } from "./options.js";
import { isNode, isCallExpression, isLiteral } from "./utils/is.js";
import { getMemberExpressionIdentifier } from "./getMemberExpressionIdentifier.js";
export function* arrayExpressionToString(node, options = {}) {
    const { externalIdentifierLookup = noop, resolveCharCode = true } = options;
    if (!isNode(node) || node.type !== "ArrayExpression") {
        return;
    }
    for (const row of node.elements) {
        if (row === null) {
            continue;
        }
        switch (row.type) {
            case "Literal": {
                if (row.value === "") {
                    continue;
                }
                if (resolveCharCode) {
                    const value = Number(row.value);
                    yield Number.isNaN(value) ?
                        String(row.value) :
                        String.fromCharCode(value);
                }
                else {
                    yield String(row.value);
                }
                break;
            }
            case "Identifier": {
                const identifier = externalIdentifierLookup(row.name);
                if (identifier !== null) {
                    yield identifier;
                }
                break;
            }
            case "CallExpression": {
                const value = joinArrayExpression(row, {
                    externalIdentifierLookup
                });
                if (value !== null) {
                    yield value;
                }
                break;
            }
        }
    }
}
export function joinArrayExpression(node, options = {}) {
    if (!isCallExpression(node)) {
        return null;
    }
    if (node.arguments.length !== 1 ||
        (node.callee.type !== "MemberExpression" ||
            node.callee.object.type !== "ArrayExpression")) {
        return null;
    }
    const id = Array.from(getMemberExpressionIdentifier(node.callee)).join(".");
    if (id !== "join" ||
        !isLiteral(node.arguments[0])) {
        return null;
    }
    const separator = node.arguments[0].value;
    const iter = arrayExpressionToString(node.callee.object, {
        ...options,
        resolveCharCode: false
    });
    return [...iter].join(separator);
}
//# sourceMappingURL=arrayExpression.js.map