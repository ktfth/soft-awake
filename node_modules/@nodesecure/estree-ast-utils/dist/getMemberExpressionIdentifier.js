import { Hex } from "@nodesecure/sec-literal";
// Import Internal Dependencies
import { concatBinaryExpression } from "./concatBinaryExpression.js";
import { noop } from "./options.js";
/**
 * Return the complete identifier of a MemberExpression
 */
export function* getMemberExpressionIdentifier(node, options = {}) {
    const { externalIdentifierLookup = noop } = options;
    switch (node.object.type) {
        // Chain with another MemberExpression
        case "MemberExpression":
            yield* getMemberExpressionIdentifier(node.object, options);
            break;
        case "Identifier":
            yield node.object.name;
            break;
        // Literal is used when the property is computed
        case "Literal":
            if (typeof node.object.value === "string") {
                yield node.object.value;
            }
            break;
    }
    switch (node.property.type) {
        case "Identifier": {
            const identifierValue = externalIdentifierLookup(node.property.name);
            if (identifierValue === null) {
                yield node.property.name;
            }
            else {
                yield identifierValue;
            }
            break;
        }
        // Literal is used when the property is computed
        case "Literal":
            if (typeof node.property.value === "string") {
                yield node.property.value;
            }
            break;
        // foo.bar[callexpr()]
        case "CallExpression": {
            const args = node.property.arguments;
            if (args.length > 0 &&
                args[0].type === "Literal" &&
                typeof args[0].value === "string" &&
                Hex.isHex(args[0].value)) {
                yield Buffer.from(args[0].value, "hex").toString();
            }
            break;
        }
        // foo.bar["k" + "e" + "y"]
        case "BinaryExpression": {
            const literal = [...concatBinaryExpression(node.property, options)].join("");
            if (literal.trim() !== "") {
                yield literal;
            }
            break;
        }
    }
}
//# sourceMappingURL=getMemberExpressionIdentifier.js.map