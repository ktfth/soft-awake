// Import Third-party Dependencies
import { Hex } from "@nodesecure/sec-literal";
// Import Internal Dependencies
import { concatBinaryExpression } from "./concatBinaryExpression.js";
import { noop } from "./options.js";
export function getCallExpressionArguments(node, options = {}) {
    const { externalIdentifierLookup = noop } = options;
    if (
    // eslint-disable-next-line no-eq-null
    node == null ||
        node.type !== "CallExpression" ||
        node.arguments.length === 0) {
        return null;
    }
    const literalsNode = [];
    for (const arg of node.arguments) {
        switch (arg.type) {
            case "Identifier": {
                const identifierValue = externalIdentifierLookup(arg.name);
                if (identifierValue !== null) {
                    literalsNode.push(identifierValue);
                }
                break;
            }
            case "Literal": {
                if (typeof arg.value === "string") {
                    literalsNode.push(hexToString(arg.value));
                }
                break;
            }
            case "BinaryExpression": {
                const concatenatedBinaryExpr = [
                    ...concatBinaryExpression(arg, { externalIdentifierLookup })
                ].join("");
                if (concatenatedBinaryExpr !== "") {
                    literalsNode.push(concatenatedBinaryExpr);
                }
                break;
            }
        }
    }
    return literalsNode.length === 0 ? null : literalsNode;
}
function hexToString(value) {
    return Hex.isHex(value) ? Buffer.from(value, "hex").toString() : value;
}
//# sourceMappingURL=getCallExpressionArguments.js.map