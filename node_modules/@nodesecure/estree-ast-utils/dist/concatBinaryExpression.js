// Import Internal Dependencies
import { arrayExpressionToString } from "./arrayExpression.js";
import { noop } from "./options.js";
// CONSTANTS
const kBinaryExprTypes = new Set([
    "Literal",
    "BinaryExpression",
    "ArrayExpression",
    "Identifier"
]);
export function* concatBinaryExpression(node, options = {}) {
    const { externalIdentifierLookup = noop, stopOnUnsupportedNode = false } = options;
    const { left, right } = node;
    if (stopOnUnsupportedNode &&
        (!kBinaryExprTypes.has(left.type) || !kBinaryExprTypes.has(right.type))) {
        throw new Error("concatBinaryExpression:: Unsupported node detected");
    }
    for (const childNode of [left, right]) {
        switch (childNode.type) {
            case "BinaryExpression": {
                yield* concatBinaryExpression(childNode, {
                    externalIdentifierLookup,
                    stopOnUnsupportedNode
                });
                break;
            }
            case "ArrayExpression": {
                yield* arrayExpressionToString(childNode, { externalIdentifierLookup });
                break;
            }
            case "Literal":
                if (typeof childNode.value === "string") {
                    yield childNode.value;
                }
                break;
            case "Identifier": {
                const identifier = externalIdentifierLookup(childNode.name);
                if (identifier) {
                    yield identifier;
                }
                break;
            }
        }
    }
}
//# sourceMappingURL=concatBinaryExpression.js.map