import type { ESTree } from "meriyah";
import type { SourceFile } from "./SourceFile.js";
import type { OptionalWarningName } from "./warnings.js";
export type ProbeReturn = void | null | symbol;
export type ProbeContextDef = Record<string, any>;
export type ProbeContext<T extends ProbeContextDef = ProbeContextDef> = {
    sourceFile: SourceFile;
    context?: T;
};
export type ProbeMainContext<T extends ProbeContextDef = ProbeContextDef> = ProbeContext<T> & {
    data?: any;
    signals: typeof ProbeRunner.Signals;
};
export type ProbeValidationCallback<T extends ProbeContextDef = ProbeContextDef> = (node: ESTree.Node, ctx: ProbeContext<T>) => [boolean, any?];
export interface Probe<T extends ProbeContextDef = ProbeContextDef> {
    name: string;
    initialize?: (ctx: ProbeContext<T>) => void | ProbeContext;
    finalize?: (ctx: ProbeContext<T>) => void;
    validateNode: ProbeValidationCallback<T> | ProbeValidationCallback<T>[];
    main: (node: any, ctx: ProbeMainContext<T>) => ProbeReturn;
    teardown?: (ctx: ProbeContext<T>) => void;
    breakOnMatch?: boolean;
    breakGroup?: string;
    context?: T;
}
export declare class ProbeRunner {
    #private;
    probes: Probe[];
    sourceFile: SourceFile;
    static Signals: Readonly<{
        Break: symbol;
        Skip: symbol;
        Continue: null;
    }>;
    /**
     * Note:
     * The order of the table has an importance/impact on the correct execution of the probes
     */
    static Defaults: Probe[];
    static Optionals: Record<OptionalWarningName, Probe>;
    constructor(sourceFile: SourceFile, probes?: Probe[]);
    walk(node: ESTree.Node): null | "skip";
    finalize(): void;
}
//# sourceMappingURL=ProbeRunner.d.ts.map