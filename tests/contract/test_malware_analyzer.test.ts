import { MalwareAnalyzer } from '../../src/services/MalwareAnalyzer';
import { Package } from '../../src/models/Package';
import { AnalysisReport } from '../../src/models/AnalysisReport';

describe('MalwareAnalyzer Contract', () => {
  let analyzer: MalwareAnalyzer;

  beforeEach(() => {
    analyzer = new MalwareAnalyzer();
  });

  describe('analyzePackage Method', () => {
    it('should accept Package and options as input', async () => {
      const mockPackage = new Package({
        name: 'express',
        version: '4.18.2',
        publishedDate: new Date(),
      });
      const options = { depth: 5, timeout: 30 };
      
      expect(() => analyzer.analyzePackage(mockPackage, options)).not.toThrow();
    });

    it('should return AnalysisReport', async () => {
      const mockPackage = new Package({
        name: 'express',
        version: '4.18.2',
        publishedDate: new Date(),
      });
      const options = {};
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result).toBeInstanceOf(AnalysisReport);
      expect(result.packageName).toBe('express');
      expect(result.packageVersion).toBe('4.18.2');
    });

    it('should include analysis metadata', async () => {
      const mockPackage = new Package({
        name: 'lodash',
        version: '4.17.21',
        publishedDate: new Date(),
      });
      const options = {};
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result.analysisMetadata).toBeDefined();
      expect(result.analysisMetadata.analyzerId).toMatch(/soft-awake-v\d+\.\d+\.\d+/);
      expect(result.analysisMetadata.staticAnalysisTools).toBeInstanceOf(Array);
    });

    it('should generate security alerts for vulnerable packages', async () => {
      const vulnerablePackage = new Package({
        name: 'vulnerable-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = {};
      
      const result = await analyzer.analyzePackage(vulnerablePackage, options);
      expect(result.securityAlerts).toBeInstanceOf(Array);
      expect(result.overallRiskScore).toBeGreaterThan(0);
      expect(result.riskLevel).toMatch(/^(LOW|MEDIUM|HIGH|CRITICAL)$/);
    });

    it('should include execution time in milliseconds', async () => {
      const mockPackage = new Package({
        name: 'test-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = {};
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result.executionTime).toBeGreaterThan(0);
      expect(typeof result.executionTime).toBe('number');
    });

    it('should set cache expiry date', async () => {
      const mockPackage = new Package({
        name: 'test-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = {};
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result.cacheExpiry).toBeInstanceOf(Date);
      expect(result.cacheExpiry.getTime()).toBeGreaterThan(result.timestamp.getTime());
    });
  });

  describe('Error Handling', () => {
    it('should throw PackageNotFound for non-existent packages', async () => {
      const nonExistentPackage = new Package({
        name: 'non-existent-package-xyz',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = {};
      
      await expect(analyzer.analyzePackage(nonExistentPackage, options))
        .rejects.toThrow('PackageNotFound');
    });

    it('should throw AnalysisTimeout for long-running analysis', async () => {
      const mockPackage = new Package({
        name: 'complex-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = { timeout: 1 }; // 1 second timeout
      
      await expect(analyzer.analyzePackage(mockPackage, options))
        .rejects.toThrow('AnalysisTimeout');
    });

    it('should throw APIRateLimit when rate limit exceeded', async () => {
      const mockPackage = new Package({
        name: 'test-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = {};
      
      // Simulate rate limit by making many requests
      const promises = Array(100).fill(null).map(() => 
        analyzer.analyzePackage(mockPackage, options)
      );
      
      await expect(Promise.all(promises)).rejects.toThrow('APIRateLimit');
    });
  });

  describe('Analysis Options', () => {
    it('should respect depth option for dependency analysis', async () => {
      const mockPackage = new Package({
        name: 'package-with-deps',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = { depth: 3 };
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result.analysisMetadata.analysisDepth).toBe(3);
    });

    it('should respect timeout option', async () => {
      const mockPackage = new Package({
        name: 'test-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = { timeout: 5 };
      
      const startTime = Date.now();
      await analyzer.analyzePackage(mockPackage, options);
      const duration = Date.now() - startTime;
      
      expect(duration).toBeLessThan(6000); // Should complete within timeout + margin
    });

    it('should use specified LLM model when provided', async () => {
      const mockPackage = new Package({
        name: 'test-package',
        version: '1.0.0',
        publishedDate: new Date(),
      });
      const options = { llmModel: 'gpt-4-turbo' };
      
      const result = await analyzer.analyzePackage(mockPackage, options);
      expect(result.analysisMetadata.llmModel).toBe('gpt-4-turbo');
    });
  });
});